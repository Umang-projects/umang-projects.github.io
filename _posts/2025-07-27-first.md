---
title: "From Model Compression to CUDA Optimization"
categories: [CUDA, Deep Learning]
tags: [optimization, gpu, tiling, performance, matrix multiplication]
---

# From Model Compression to CUDA Optimization:

## Benchmark Data (The ‚ÄúProof‚Äù Hook)-Performance Summary

Before diving into the discovery process, here‚Äôs a quick look at the numbers that show just how effective tiling can be for matrix multiplication on GPUs:

### Test Configuration:

- **GPU**: Colab T4
- **Matrix size**: 16,384√ó16,384 (268 million elements)
- **Precision**: FP32 (single precision)
- **Tile size**: 32√ó32

| Implementation         | Runtime    | Speedup   | Memory Saved | Time Saved |
| ---------------------- | ---------- | --------- | ------------ | ---------- |
| Baseline (Coalesced)   | 14.32‚ÄØs    | 1.00√ó     | ‚Äî            | ‚Äî          |
| **Tiled Optimization** | **9.04‚ÄØs** | **1.58√ó** | **\~37%**    | **5.28‚ÄØs** |

**Key Insights:**

- ‚ö° **58% faster computation** ‚Äî tiling benefits scale dramatically with matrix size.
- ‚è±Ô∏è **5.3 seconds saved** per operation ‚Äî critical at production scale.
- üìä **Scaling Law**: Increasing from 2K√ó2K to 16K√ó16K matrix showed a 4√ó larger speedup gain.

---

## How I Discovered Tiling

As a deep learning practitioner with a strong interest in linear algebra, my work has focused on making large language models more efficient. In a recent project, **HyLoRA**, I used techniques like Singular Value Decomposition (SVD) to achieve over 60% compression on a LLaMA-based model. This experience with high-level model optimization made me want to go deeper‚Äîto understand the performance bottlenecks not at the algorithmic level, but at the hardware level. To do this, I began learning CUDA C++ to see how the fundamental linear algebra operations, like matrix multiplication, are actually executed. This is the story of how I tackled the performance puzzle of a basic matrix multiplication kernel and re-discovered the critical optimization strategy known as **tiling**.

## The Problem Hit Me Like a Brick Wall

When I first looked at basic matrix multiplication kernels, I immediately thought ‚Äúthis is completely stupid.‚Äù Every single thread was making individual trips to the slow main memory for every calculation. It felt so wasteful.

Think about it this way: imagine you have a thousand workers, and each one keeps running to this distant library every time they need to look up just one number. They spend way more time traveling back and forth than actually doing any useful work! That's exactly what was happening in these naive GPU kernels.

I realized the real enemy wasn't computation ‚Äî GPUs are incredible at math. The enemy was **memory bandwidth**. All these threads were just sitting around waiting for data to arrive from slow global memory instead of doing the work they were designed to do.

This felt like such a fundamental inefficiency that I knew there had to be a better way to approach the problem.

## Started Working on This Problem

I decided to approach this from first principles, the way I'd think about any optimization problem. If I have a team of workers, why would I let them act like completely isolated individuals? They should work together intelligently.

### First Thought: Break This Thing Down

My first insight was that trying to think about the entire huge matrix multiplication at once was just overwhelming. The matrices are massive, and trying to optimize the whole thing as one unit felt impossible.

My brain naturally went to ‚Äúokay, let's break this down into smaller pieces that actually make sense to work with.‚Äù If I can't handle the whole problem efficiently, maybe I can handle lots of smaller sub-problems really well.

In CUDA terminology, these smaller pieces are called **tiles**. So my idea was: assign one team of workers (a **thread block**) to handle just one small tile of the final answer matrix. Each team becomes responsible for their own little piece of the puzzle.

### Second Thought: Give Each Team Their Own Workspace

Once I had teams working on individual tiles, my next thought was that each team needs somewhere to collaborate efficiently. They need a shared table or workspace where they can organize their materials and work together without interfering with other teams.

That's exactly what **shared memory** is in CUDA! It's this fast, on-chip memory that's way faster than the main global memory. I can create this workspace using the `__shared__` keyword, and it becomes like giving each team their own private, high-speed workspace that only they can access.

### Third Thought: Plan the Work Before You Start Working

Here's where the key insight hit me: before anyone starts doing any actual calculations, the whole team should coordinate to gather all the data they're going to need for their tile. No more of this nonsense where individual workers keep making separate trips to that slow global memory.

Instead, what if the entire team works together to make one organized, efficient trip to global memory? They can grab all the data they need for their current phase of work and bring it back to their fast shared workspace.

In CUDA terms, this is called a **cooperative load**. All the threads in a block coordinate to perform fast, **coalesced reads** from global memory, filling up their shared memory workspace with everything they need for the next phase of computation.

### Fourth Thought: Now You Can Actually Do the Math Efficiently

Once the preparation phase is complete and all the necessary data is sitting in that fast shared memory workspace, then the real computational work can begin. Now threads can just grab the numbers they need from their local workspace and compute away without any waiting.

The way I was thinking about it: ‚Äúfirst it fills the value, then we will calculate directly there‚Äù ‚Äî prepare everything you need locally, then do all your math using the fast local data.

## A Concrete Walkthrough of Tiling in Action

To make this real, let me walk you through a simple example. Suppose we‚Äôre multiplying two 4√ó4 matrices, and we have a 2√ó2 team of threads responsible for calculating the top-left 2√ó2 block of the result.

**Matrix M:**

```
[  0,  1,  2,  3 ]
[  4,  5,  6,  7 ]
[  8,  9, 10, 11 ]
[ 12, 13, 14, 15 ]
```

**Matrix N:**

```
[ 100, 101, 102, 103 ]
[ 104, 105, 106, 107 ]
[ 108, 109, 110, 111 ]
[ 112, 113, 114, 115 ]
```

### Phase 1: First Chunk Load & Compute

- **Preparation**: The 2√ó2 team cooperatively loads the first 2√ó2 chunks into shared memory:

  - Worker (0,0) loads M[0] and N[100]
  - Worker (0,1) loads M[1] and N[101]
  - Worker (1,0) loads M[4] and N[104]
  - Worker (1,1) loads M[5] and N[105]

  ```
  Shared M: [ 0, 1 ]    Shared N: [100, 101]
            [ 4, 5 ]              [104, 105]
  ```

- `__syncthreads()` to ensure all loads complete.

- **Computation**:

  - (0,0): (0√ó100) + (1√ó104) = 104
  - (0,1): (0√ó101) + (1√ó105) = 105
  - (1,0): (4√ó100) + (5√ó104) = 920
  - (1,1): (4√ó101) + (5√ó105) = 929

### Phase 2: Second Chunk Load & Finalize

- **Preparation**: Load next 2√ó2 chunks:

  - Worker (0,0): M[2], N[108]
  - Worker (0,1): M[3], N[109]
  - Worker (1,0): M[6], N[112]
  - Worker (1,1): M[7], N[113]

  ```
  Shared M: [ 2, 3 ]    Shared N: [108, 109]
            [ 6, 7 ]              [112, 113]
  ```

- `__syncthreads()` again.

- **Computation**:

  - (0,0): 104 + (2√ó108) + (3√ó112) = 656
  - (0,1): 105 + (2√ó109) + (3√ó113) = 662
  - (1,0): 920 + (6√ó108) + (7√ó112) = 2352
  - (1,1): 929 + (6√ó109) + (7√ó113) = 2374

**Finalization**: Each thread writes its result to the output matrix, reducing global memory trips.

## Translating Intuition to CUDA Code

```cuda
const int TILE_WIDTH = 32;

__global__ void matmul_optimized_simple(const float* A, const float* B, float* C, int N) {
    // Shared memory for tiles of A and B
    __shared__ float ds_A[TILE_WIDTH][TILE_WIDTH];
    __shared__ float ds_B[TILE_WIDTH][TILE_WIDTH];

    // Thread index in the block
    int tx = threadIdx.x;
    int ty = threadIdx.y;

    // Global row and column for the element this thread will compute
    int row = blockIdx.y * TILE_WIDTH + ty;
    int col = blockIdx.x * TILE_WIDTH + tx;

    // Accumulator for the result
    float p_value = 0;

    // Loop over the tiles of A and B required to compute the C element
    for (int m = 0; m < N / TILE_WIDTH; ++m) {
        // Collaboratively load tiles into shared memory.
        // No boundary checks here assumes N % TILE_WIDTH == 0.
        // This is a direct, divergence-free load.
        ds_A[ty][tx] = A[row * N + (m * TILE_WIDTH + tx)];
        ds_B[ty][tx] = B[(m * TILE_WIDTH + ty) * N + col];

        // Synchronize to ensure both tiles are fully loaded before proceeding.
        __syncthreads();

        // Perform the matrix multiplication on the tiles in shared memory.
        // This loop has no divergence as all threads execute it.
        for (int k = 0; k < TILE_WIDTH; ++k) {
            p_value += ds_A[ty][k] * ds_B[k][tx];
        }

        // Synchronize to ensure all calculations with the current tiles are
        // finished before loading the next tiles in the next iteration.
        __syncthreads();
    }

    // Write the final result to global memory.
    if (row < N && col < N) {
        C[row * N + col] = p_value;
    }
}
```

---

## 7. Real-World Impact Statement

> For a 175B-parameter large language model inference, tiling reduces GPU memory bandwidth pressure by **40%**. This enables **faster chatbot response times** or **doubles the number of concurrent users served per GPU**.

---

## 8. Visual Aid: Shared Memory Workflow

```
Global Memory ‚Üí [Cooperative Load] ‚Üí Shared Memory Tile ‚Üí [Threads Compute] ‚Üí Output
```



**9. Jargon Footnotes for Wider Reach**

- **Thread blocks**: Groups of GPU threads that collaborate within shared memory.
- **Coalesced reads**: Memory access pattern where consecutive threads read consecutive memory locations.
- \`\`: Barrier to ensure all threads in a block have reached the same execution point.

---

## 10. Why This Matters

- Every core operation in modern AI‚Äîmatrix multiplies in transformers, convolutions in CNNs, attention in language models‚Äîrelies on these optimization principles.
- As model size increases, the impact of even minor GPU efficiency gains compounds significantly.

---

## 11. Conclusion

Rediscovering tiling through first-principles problem solving not only taught me a crucial GPU optimization but also reinforced my belief that **deep understanding‚Äîacross both math and hardware‚Äîis essential** for building cutting-edge, efficient AI systems.

